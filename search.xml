<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一次有趣的High load average排查暨深刻理解Linux系统负载</title>
      <link href="/2019/05/16/linux-load-average-nfs-hang/"/>
      <url>/2019/05/16/linux-load-average-nfs-hang/</url>
      
        <content type="html"><![CDATA[<p>当Linux服务运行慢的时候，我们一般都是用top命令看看当前CPU使用率以及哪些进程占用了资源等。资深一些管理员，会通过查看load average来查看系统负载以评估系统是越来越慢还是会越来越快。正常情况下，系统没有活跃进程时，系统的负载是0， 如下所示（用uptime):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uptime</span><br><span class="line"> 03:07am  up   0:38,  2 users,  load average: 0.00, 0.00, 0.02</span><br></pre></td></tr></table></figure></p><p>可是有一次有台机会变慢，load average很高，但是CPU 使用率接近于0，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top - 05:15:28 up  2:25,  2 users,  load average: 18.44, 18.47, 18.32</span><br><span class="line">Tasks: 144 total,   1 running, 143 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  0.8 sy,  0.0 ni, 99.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu2  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu3  :  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></pre></td></tr></table></figure></p><p>如果是使用vmstats/iostat,都没办法发现是什么导致High load average和机器变慢。在大量Google之后，最终怀疑到是因为有一个NFS mount的服务器可能down了，大量的df进程导致系统High load average，下面我们细细分析个中原因。</p><a id="more"></a><h2 id="什么是Load-Average"><a href="#什么是Load-Average" class="headerlink" title="什么是Load Average"></a>什么是Load Average</h2><p>Load表示是Linux系统中对当前CPU工作量的度量，简单来说就是CPU需要运行进程数量的队列长度（==不是CPU使用比率，所以值是会大于1==）。而Load average则是分别统计系统1分钟、5分钟、15分钟平均Load。 如上面top所示，1分钟平均负载是18.44，5分钟平均负载是18.49，15分钟平均负载是17.46。<br>当平均负载远高于系统CPU数量，则意味系统负载比较重。如果1分钟负载比较低而15分钟负载比较高，则意味着系统负载将降低。反之，则意味着系统负载将越来越高。这时候我们需要关注是否某些进程消耗大量I/O，CPU或者Memory等。<br>Load Average的评估经常需要和当前系统CPU数量关联起来分析。</p><h5 id="单核CPU"><a href="#单核CPU" class="headerlink" title="- 单核CPU"></a>- 单核CPU</h5><p>假设我们的系统是单核的CPU，把它比喻成是一条单向马路，把CPU任务比作汽车。当车占满整个马路的时候 load=1；当车不多的时候，load &lt;1；当马路都站满了，而且马路外还堆满了汽车的时候，load&gt;1，如下所示:<br><img src="https://img-blog.csdnimg.cn/20190516132631207.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pncWFsbGVu,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="多核CPU"><a href="#多核CPU" class="headerlink" title="- 多核CPU"></a>- 多核CPU</h5><p>现代机器基本都是多核CPU，所以即便有时候Load average比较高，系统任然可以运行的比较顺畅。假设我们服务器CPU是2核，那么将意味我们拥有2条马路，我们的Load = 2时，所有马路都跑满车辆，如下所示：<br><img src="https://img-blog.csdnimg.cn/20190516132954619.JPG" alt="在这里插入图片描述"></p><h2 id="Load-Average是如何计算出来的"><a href="#Load-Average是如何计算出来的" class="headerlink" title="Load Average是如何计算出来的"></a>Load Average是如何计算出来的</h2><p>无论是uptime还是top命令输入的load average其实是读取了文件/proc/loadavg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/loadavg</span><br><span class="line">18.60 18.51 17.67 2/178 11202</span><br></pre></td></tr></table></figure></p><p>前面三个数字是1、5、15分钟内的平均进程数，第四数字是当前运行的进程数量（分子）和总进程数（分母），第五个数字是最后使用的进程ID。<br>/proc/loadavg实际上是内核schedule进程更新，通过proc fs 曝露给user的。我们通过查看一下Linux 内核源代码就可以窥探一二Load average是如何计算出来的。<br><a href="https://github.com/torvalds/linux/blob/master/include/linux/sched/loadavg.h" target="_blank" rel="noopener">include/linux/sched/loadavg.h</a>定义了一定时间Load Average的计算算法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#define LOAD_FREQ(5*HZ+1)/* 5 sec intervals */</span><br><span class="line">#define EXP_11884/* 1/exp(5sec/1min) as fixed-point */</span><br><span class="line">#define EXP_52014/* 1/exp(5sec/5min) */</span><br><span class="line">#define EXP_152037/* 1/exp(5sec/15min) */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * a1 = a0 * e + a * (1 - e)</span><br><span class="line"> */</span><br><span class="line">static inline unsigned long</span><br><span class="line">calc_load(unsigned long load, unsigned long exp, unsigned long active)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long newload;</span><br><span class="line"></span><br><span class="line">newload = load * exp + active * (FIXED_1 - exp);</span><br><span class="line">if (active &gt;= load)</span><br><span class="line">newload += FIXED_1-1;</span><br><span class="line"></span><br><span class="line">return newload / FIXED_1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c" target="_blank" rel="noopener">kernel/sched/loadavg.c</a>计算active task 数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">long calc_load_fold_active(struct rq *this_rq, long adjust)</span><br><span class="line">&#123;</span><br><span class="line">long nr_active, delta = 0;</span><br><span class="line"></span><br><span class="line">nr_active = this_rq-&gt;nr_running - adjust;</span><br><span class="line">nr_active += (long)this_rq-&gt;nr_uninterruptible;</span><br><span class="line"></span><br><span class="line">if (nr_active != this_rq-&gt;calc_load_active) &#123;</span><br><span class="line">delta = nr_active - this_rq-&gt;calc_load_active;</span><br><span class="line">this_rq-&gt;calc_load_active = nr_active;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更多细节可以通过查看源代码来理解。</p><h2 id="为什么NFS-hang会导致High-Load-Average"><a href="#为什么NFS-hang会导致High-Load-Average" class="headerlink" title="为什么NFS hang会导致High Load Average"></a>为什么NFS hang会导致High Load Average</h2><p>现在我们已经知道Load average是咋么计算出来以及它的意义，我们会过来分析为什么NFS hang会导致High Load Average。其实这是Linux对Load计算一个缺陷。Linux上的load average除了包括正在使用CPU的进程数量和正在等待CPU的进程数量之外，还包括uninterruptible sleep的进程数量（==如函数calc_load_fold_active(）所示==）。通常等待IO设备、等待网络的时候，进程会处于uninterruptible sleep状态。Linux设计者的逻辑是，uninterruptible sleep应该都是很短暂的，很快就会恢复运行，所以被等同于runnable。但是对于NFS 来说，假设服务器一直没有恢复，那么任何对于该mount目录操作都将hang住，该进程会一直处于uninterruptible状态。在本例中，由于有个cron job定期统计NFS磁盘使用量，导致有大量df进程hang住。如下所示（D表示uninterruptible）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># ps -auxwww | grep D</span><br><span class="line">zgqadm    7675  0.0  0.0   5816  1320 tty1     D    04:02   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7676  0.0  0.0   5816  1336 tty1     D    04:02   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7677  0.0  0.0   5816  1356 tty1     D    04:02   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7678  0.0  0.0   5816  1344 tty1     D    04:02   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7679  0.0  0.0   5816  1308 tty1     D    04:02   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7680  0.0  0.0   5816  1352 tty1     D    04:02   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7681  0.0  0.0   5816  1308 tty1     D    04:02   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7682  0.0  0.0   5816  1356 tty1     D    04:02   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7761  0.0  0.0   5816  1324 tty1     D    04:03   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7762  0.0  0.0   5816  1344 tty1     D    04:03   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7763  0.0  0.0   5816  1376 tty1     D    04:03   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7764  0.0  0.0   5816  1340 tty1     D    04:03   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7765  0.0  0.0   5816  1260 tty1     D    04:03   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7766  0.0  0.0   5816  1360 tty1     D    04:03   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7767  0.0  0.0   5816  1316 tty1     D    04:03   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7768  0.0  0.0   5816  1260 tty1     D    04:03   0:00 df -Pk /nfsshare</span><br><span class="line">zgqadm    7769  0.0  0.0   5816  1376 tty1     D    04:03   0:00 df -Pk /nfsshare</span><br></pre></td></tr></table></figure></p><h6 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h6><hr><p> [1] <a href="https://scoutapm.com/blog/understanding-load-averages" target="_blank" rel="noopener">Understanding Linux CPU Load - when should you be worried</a><br> [2] <a href="http://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html" target="_blank" rel="noopener">Linux Load Averages: Solving the Mystery</a><br> [3] <a href="http://linuxperf.com/?p=176" target="_blank" rel="noopener">理解LINUX LOAD AVERAGE的误区</a></p>]]></content>
      
      
      <categories>
          
          <category> Knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Load Average, NFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux虚拟内存介绍以及glibc内存管理机制窥探</title>
      <link href="/2019/05/14/linux-glic-mm-overview/"/>
      <url>/2019/05/14/linux-glic-mm-overview/</url>
      
        <content type="html"><![CDATA[<p>Long ago, I have presentd an overview of virtual memory in Linux kernel and memory memory in glibc. Now i am lazy to write these again, so I try to upload the PPT in images. As you know, each pages has details knowledge could be digged into, so you have further view, please google the keywords.</p><h2 id="Overview-of-VM-system-in-Linux"><a href="#Overview-of-VM-system-in-Linux" class="headerlink" title="Overview of VM system in Linux"></a>Overview of VM system in Linux</h2><p><img src="/images/memory/Slide3.PNG" alt="VM"><br><a id="more"></a></p><h2 id="Overview-of-MMU-and-Buddy-amp-Slab-allocator"><a href="#Overview-of-MMU-and-Buddy-amp-Slab-allocator" class="headerlink" title="Overview of MMU and Buddy &amp; Slab allocator"></a>Overview of MMU and Buddy &amp; Slab allocator</h2><p><img src="/images/memory/Slide4.PNG" alt="VM"></p><h2 id="LifeCycle-of-Page-frames"><a href="#LifeCycle-of-Page-frames" class="headerlink" title="LifeCycle of Page frames"></a>LifeCycle of Page frames</h2><p><img src="/images/memory/Slide5.PNG" alt="VM"></p><h2 id="Address-Space-and-VMA-mapping-in-Kernel"><a href="#Address-Space-and-VMA-mapping-in-Kernel" class="headerlink" title="Address Space and VMA mapping in Kernel"></a>Address Space and VMA mapping in Kernel</h2><p><img src="/images/memory/Slide6.PNG" alt="VM"></p><h2 id="Pic-for-summary-memory-in-Kernel"><a href="#Pic-for-summary-memory-in-Kernel" class="headerlink" title="Pic for summary memory in Kernel"></a>Pic for summary memory in Kernel</h2><p><img src="/images/memory/Slide7.PNG" alt="VM"></p><h2 id="Glibc-memory-allocation-concepts"><a href="#Glibc-memory-allocation-concepts" class="headerlink" title="Glibc memory allocation concepts"></a>Glibc memory allocation concepts</h2><p><img src="/images/memory/Slide8.PNG" alt="VM"></p><h2 id="Brk-and-mmap"><a href="#Brk-and-mmap" class="headerlink" title="Brk and mmap"></a>Brk and mmap</h2><p><img src="/images/memory/Slide9.PNG" alt="VM"></p><h2 id="Internal-structure-of-glibc"><a href="#Internal-structure-of-glibc" class="headerlink" title="Internal structure of glibc"></a>Internal structure of glibc</h2><p><img src="/images/memory/Slide10.PNG" alt="VM"></p><h2 id="malloc-and-free-process-in-glibc"><a href="#malloc-and-free-process-in-glibc" class="headerlink" title="malloc and free process in glibc"></a>malloc and free process in glibc</h2><p><img src="/images/memory/Slide11.PNG" alt="VM"></p><h2 id="Some-keypoints-for-glibc"><a href="#Some-keypoints-for-glibc" class="headerlink" title="Some keypoints for glibc"></a>Some keypoints for glibc</h2><p><img src="/images/memory/Slide12.PNG" alt="VM"></p><h2 id="Tips-for-heap-profile"><a href="#Tips-for-heap-profile" class="headerlink" title="Tips for heap profile"></a>Tips for heap profile</h2><p><img src="/images/memory/Slide13.PNG" alt="VM"></p>]]></content>
      
      
      <categories>
          
          <category> Knowledge </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Virtual_Memory </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cscope Usage</title>
      <link href="/2017/08/02/cscope-usage/"/>
      <url>/2017/08/02/cscope-usage/</url>
      
        <content type="html"><![CDATA[<p>Actually the source insight is the fist choice code viewing tool for me, but it requires license and in Linux the vim is the powerful editor for me. So to better understanding the code, cscope is the best choice for me to read code in vim. Now i used the cscope more and more often.</p><h2 id="Generate-the-cscope-meta-data"><a href="#Generate-the-cscope-meta-data" class="headerlink" title="Generate the cscope meta data"></a>Generate the cscope meta data</h2><p>Enter below commands at the top dir of the project, and then cscope.out will be generated:</p><blockquote><p>find . -name “*.h” -o -name “*.c” -o -name “*.cc” -o -name “*.cpp” &gt; cscope.files<br>cscope -bqR -i cscope.files</p></blockquote><p>More parameters you can refer to cscope -h.<br><a id="more"></a></p><h2 id="Use-cscope-to-read-code"><a href="#Use-cscope-to-read-code" class="headerlink" title="Use cscope to read code"></a>Use cscope to read code</h2><p>After the cscope utility installed, you can vim a file as normal and input the cscope command, below help will show:</p><blockquote><p>:cscope<br>cscope commands:<br>   add : Add a new database    (Usage: add file|dir [pre-path] [flags])<br>   find : Query for a pattern    (Usage: find c|d|e|f|g|i|s|t name)<br>      c: Find functions calling this function<br>      d: Find functions called by this function<br>      e: Find this egrep pattern<br>      f: Find this file<br>      g: Find this definition<br>      i: Find files #including this file<br>      s: Find this C symbol<br>      t: Find assignments to<br>   help : Show this message              (Usage: help)<br>   kill : Kill a connection              (Usage: kill #)<br>   reset: Reinit all connections         (Usage: reset)<br>   show : Show connections               (Usage: show)</p></blockquote><p>Chinese reference:</p><blockquote><p>s: 查找C语言符号，即查找函数名、宏、枚举值等出现的地方<br>g: 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能<br>d: 查找本函数调用的函数<br>c: 查找调用本函数的函数<br>t: 查找指定的字符串<br>e: 查找egrep模式，相当于egrep功能，但查找速度快多了<br>f: 查找并打开文件，类似vim的find功能<br>i: 查找包含本文件的文件</p></blockquote><h2 id="HotKeys-defined-for-quick-usage"><a href="#HotKeys-defined-for-quick-usage" class="headerlink" title="HotKeys defined for quick usage"></a>HotKeys defined for quick usage</h2><p>Download the cscope HotKeys maps <a href="http://cscope.sourceforge.net/cscope_maps.vim" target="_blank" rel="noopener">cscope_maps.vim</a>, and puts in dir <code>~/.vim/plugin/</code>. More details you can refer to the files, here I introduces the useful commands for me in daily works:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nmap &lt;C-\&gt;s :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;C-\&gt;g :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;C-\&gt;c :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;C-\&gt;t :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;C-\&gt;e :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;C-\&gt;f :cs find f &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br><span class="line">nmap &lt;C-\&gt;i :cs find i ^&lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;$&lt;CR&gt;</span><br><span class="line">nmap &lt;C-\&gt;d :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;</span><br></pre></td></tr></table></figure></p><p>Firstly move the cursor to the keyword which want to find, and then press the key <code>ctrl + &#39;\&#39;</code>, and then type option character, it will be the quick access to <code>:cscope find \* some_string</code>.</p><p>Another two useful quick hot key:<br><code>ctrl + ]</code> - Quickly redirect to the function definition.<br><code>ctrl + t</code> - Quickly back to the last frame.</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cscope </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced GDB Usage</title>
      <link href="/2017/07/31/gdb-usage/"/>
      <url>/2017/07/31/gdb-usage/</url>
      
        <content type="html"><![CDATA[<p>This Page was a summary of the advanced gdb usge in daily work, for the basic usage of gdb will not being described here.</p><h2 id="1-Advanced-commands-in-using"><a href="#1-Advanced-commands-in-using" class="headerlink" title="1. Advanced commands in using"></a>1. Advanced commands in using</h2><blockquote><p>gdb&gt; info share - show the shared libraries load by process.<br>gdb&gt; until (line number) - run until to the line number in case you want to break out the while&amp;for loop.<br>gdb&gt; finish - run out of the this function call.<br>gdb&gt; call (function name) - call a function in current context.<br>gdb&gt; disas (function name) - check the assembly code for a function.<br>gdb&gt; run (arguments) - run the program with arguments.<br>gdb&gt; bt - get the call stack for current thread.<br>gdb&gt; frame (stack number) - change stack frame to specfic function call.<br>gdb&gt; info regs - show the values of current registers.<br>gdb&gt; list filename:line - list the code of filename:line<br>gdb&gt; info - list all info sub commands and which are helpful.</p></blockquote><a id="more"></a><h2 id="2-Set-condition-break-point-and-watch"><a href="#2-Set-condition-break-point-and-watch" class="headerlink" title="2. Set condition break point and watch"></a>2. Set condition break point and watch</h2><p>we can set the normal break point as below:</p><blockquote><p>gdb&gt; break (function name)<br>gdb&gt; break filename:line<br>gdb&gt; break address</p></blockquote><p>In case you want to stop a break point in condition you can do as below:</p><blockquote><p>gdb&gt; break if val==(some value)</p></blockquote><p>But sometimes, the critical case was string comparasion, you can’t compare 2 strings with == directly. In some case, the strcmp may help you, but some are not. In these cases, below gdb native function will help:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_memeq(buf1, buf2, length) - Returns one <span class="keyword">if</span> the length bytes at the addresses given by buf1 <span class="keyword">and</span> buf2 are equal. Otherwise it returns zero.</span><br><span class="line">_streq(str1, str2) - Returns one <span class="keyword">if</span> the <span class="built_in">string</span> str matches the regular expression regex. Otherwise it returns zero. The syntax of the regular expression is that specified by Python’s regular expression support. </span><br><span class="line">_strlen(str) - Returns one <span class="keyword">if</span> the strings str1 <span class="keyword">and</span> str2 are equal. Otherwise it returns zero. </span><br><span class="line">_regex(str, regex) - Returns the length of <span class="built_in">string</span> str.</span><br></pre></td></tr></table></figure></p><p>Sometimes, you want to watch a variable but it was thread level’s variable, you can watch the address change directly as below:</p><blockquote><p>gdb&gt; p &amp;variable - get the address of the variable.<br>gdb&gt; watch *(int*)address </p></blockquote><h2 id="3-Multiple-threads-debugging-using-gdb"><a href="#3-Multiple-threads-debugging-using-gdb" class="headerlink" title="3. Multiple threads debugging using gdb"></a>3. Multiple threads debugging using gdb</h2><p>You need get some information of all  threads:</p><blockquote><p>gdb&gt; info threads – show all threads<br>gdb&gt; thread apply all bt – show call stack for all threads<br>gdb&gt; thread (thread num) – change the current thread to specfic thread.</p></blockquote><p>Sometimes you need continuing debug the current thread, but other thread schedule may break up. You can lock the thread scheduler as below:</p><blockquote><p>gdb&gt; set scheduler-locking on</p></blockquote><h2 id="4-Show-the-content-of-memory"><a href="#4-Show-the-content-of-memory" class="headerlink" title="4. Show the content of memory"></a>4. Show the content of memory</h2><p>A generic way to show the value in gdb as below:</p><blockquote><p>gdb&gt; p values|pointer</p></blockquote><p>But most cases, we may need check the values of the address directly, do as below:</p><blockquote><p>gdb&gt; x /nfu (address)<br>n - indicates the number of block want to show<br>f - indicates the format to show the address(x for hex;d for 10-ary; u for unsigned 10-ary;o for 8-ary; t for bin; i for instructions show; c for char)<br>u - the length of a address unit (b for 1 byte; h for double byte: w for 4 bytes; g for 8 bytes)</p></blockquote><h2 id="5-Define-a-function-to-call-later"><a href="#5-Define-a-function-to-call-later" class="headerlink" title="5. Define a function to call later"></a>5. Define a function to call later</h2><p>you may want to show some information without specific function, then you can define function as below call:</p><blockquote><p>gdb&gt; define function<br>gdb&gt; content<br>gdb&gt; end</p></blockquote><p>For example:</p><blockquote><p>gdb&gt; define mallocinfox<br>gdb&gt; set \$__f = fopen(“arena.txt”, “w+”)<br>gdb&gt; call malloc_info(0, \$__f)<br>gdb&gt; call fclose(\$__f)<br>gdb&gt; end</p></blockquote><h2 id="6-Gdb-in-batch-mode"><a href="#6-Gdb-in-batch-mode" class="headerlink" title="6. Gdb in batch mode"></a>6. Gdb in batch mode</h2><p>Sometimes, you just want to attach a process and get some information, but you don’t want to hold the process with gdb, you can do in batch mode as below:</p><blockquote><p>gdb -ex “set pagination 0” -ex “Command” -ex “detch” -batch -p $pid<br>For example:<br>gdb -ex “set pagination 0” -ex “thread apply all bt” -ex “detch” -batch -p 12456</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb; </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开篇</title>
      <link href="/2017/07/30/first-blog/"/>
      <url>/2017/07/30/first-blog/</url>
      
        <content type="html"><![CDATA[<p>最近闲下来有空想一些东西，至今工作已经5年了。5年之际，除了工作上得到一些小许的认可，其他好像无其他。脑海时常有一个想法，至今为止我在自己维系生计的技术方面有什么积累吗？有时候和一些小伙子侃侃而谈，可内心总觉得空虚，主要还是没有积累。查看各身边大牛，技术博客好像是必不可少的东西，即是一种积累也是一种展示内容的地方。</p><p>于是乎调研了一些大牛在哪写博客:CSDN,博客园等等，可是各平台水平参次不齐。想想自己只是想要有个地方可以积累知识，作为程序员最好的方式是自己可以控制运维。偶然间发现GitHub Pages,这种本来用来作为项目说明网页的东西，被一些大牛整成了Blog平台。虽然网络上有人批判这种行为，说以国人的脾性，很快这里将会乌烟瘴气，然后GitHub就会关闭中国的Access，然这些对于我们个人是没有办法控制的。<br><a id="more"></a></p><p>不管咋样，决定了自己Blog自己来控制，也就定下了GitHub Pages决心，期间查了很多资料。在blog维护框架Kelly和Hexo之间，最后选择了Hexo。因为偶然间看到一个大牛为Hexo做的theme很适合自己的口味。Hexo入门参考文章: <a href="https://wsgzao.github.io/post/hexo-guide/" target="_blank" rel="noopener">https://wsgzao.github.io/post/hexo-guide/</a>. FreeMind theme参考大牛Joseph Pan的GitHub <a href="https://github.com/wzpan" target="_blank" rel="noopener">https://github.com/wzpan</a> 。</p><p>由于GitHub Pages是静态的博客系统，想要最一些留言之类东西就比较麻烦，no database access support.所以很多玩GitHub  Pages的人借用一些Disqus、网易云跟贴、畅言等，可是这些平台突然某一天就不支持了，然后就没有然后了。所以大牛又自己开发一个基于GitHub issue的留言系统，自己来控制留言。请看每一页后面的Go To Comment.</p><p>现在为止，一个最重要的东西还没有时间是学习，那就是用MarkDown来写Blog。先记事本写起来，以后慢慢学习MarkDown。</p>]]></content>
      
      
      <categories>
          
          <category> 随记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub Pages; </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
